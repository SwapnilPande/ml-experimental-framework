## @package Experiment
# The Experiment module contains multiple classes for defining experiments and experiment instances
# An Experiment object contains 'independent variables' that will be tested and generates ExperimentInstance object,
# which are specific combinations of the independent variables to execute.



from abc import ABC, abstractmethod

## ExperimentInstance
# An ExperimentInstance objects contains a specific combination of the 'independent variables' of the experiment, as well as a label describing the instance
# The ExperimentInstance object will be converted into a training program by the specific plugin for the ML Framework
class ExperimentInstance():

    def __init__(self, mlFramework, instanceIdx, model, hyperparameters, dataset, optimizer, modelLabel, hyperparametersLabel, datasetLabel, optimizerLabel):

        #Storing data as instance variables
        self.mlFramework = mlFramework
        self.dataset = dataset
        self.model = model
        self.hyperparameters = hyperparameters
        self.optimizer = optimizer
        self.instanceIdx = instanceIdx

        self.label = "Experiment Instance: %(instanceIdx)s\nModel: %(modelLbl)s\nOptimizer: %(optimizerLbl)s\nHyperparameterSet: %(hpLbl)s\nDataset: %(datasetLbl)s\n" % {
            "instanceIdx" : instanceIdx,
            "modelLbl": str(modelLabel),
            "hpLbl" : str(hyperparametersLabel),
            "datasetLbl" : str(datasetLabel),
            "optimizerLbl" : str(optimizerLabel)
        }


    def getModel(self):
        return self.model
    
    def getDataset(self):
        return self.dataset

    def getHyperparameters(self):
        return self.hyperparameters

    def __str__(self):
        return self.label

## StaticExperiment 
# StaticExperiment is a base class to define an experiment involving various ML Models, hyperparameters, and datasets.
# THe ExperimentInstance objects are all generated by creating combinations of these variables. The ExperimentInstance
# objects are all created at the beginning of the experiment execution, and therefore, cannot be created or changed
# based on the results from the experimentation, hence the name static. A DynamicExperiment can be used for applications
# such as hyperparameter search

class StaticExperiment():

    def __init__(self, mlFramework, models = {}, hyperparameterSets = {}, datasets = {}, optimizers = {}):
        #Defining parameters here
        self.mlFramework = mlFramework
        self.models = models
        self.hyperparameterSets = hyperparameterSets
        self.datasets = datasets
        self.optimizers = optimizers

    @abstractmethod
    def __getitem__(self, index):
        '''
        Returns an Experiment Instance object, which will be translated into a a file to execute training
        '''

        raise NotImplementedError

    @abstractmethod
    def __len__(self):

        raise NotImplementedError


    def getExperimentInstances(self):
        instances = []
        print(len(self))
        for idx in range(0,len(self)):
            instances.append(self[idx])
        return instances


## SimpleStaticExperiment 
# The SimpleStaticExperiment is a simple example of an implementation of the StaticExperiment.
# The various models, hyperparameters, and datasets are passed when the SimpleStaticExperiment is instantiated.
# The __getitem__ method will simply return every combination of the 4 independent variables to be executed.
class SimpleStaticExperiment(StaticExperiment):


        def __init__(self, mlFramework, models = {}, hyperparameterSets = {}, datasets = {}, optimizers = {}):
            super().__init__(mlFramework, models,  hyperparameterSets, datasets, optimizers)

        
        def __len__(self):
            return len(self.datasets)*len(self.models)*len(self.hyperparameterSets)*len(self.optimizers)
        
        def __getitem__(self, index):
            if(index >= len(self)):
                #Todo: Define this exception
                raise Exception()
            else:
                tempIdx = index

                datasetIdx = tempIdx%len(self.datasets)
                tempIdx = int(tempIdx/len(self.datasets))

                hyperparameterSetIdx = tempIdx%len(self.hyperparameterSets)
                tempIdx = int(tempIdx/len(self.hyperparameterSets))

                optimizerIdx = tempIdx%len(self.optimizers)
                tempIdx = int(tempIdx/len(self.optimizers))

                modelIdx = tempIdx%len(self.models)
                
                return ExperimentInstance(self.mlFramework,
                    index,
                    self.models[modelIdx]["path"],
                    self.hyperparameterSets[hyperparameterSetIdx]["hyperparameters"],
                    self.datasets[datasetIdx]["path"],
                    self.optimizers[optimizerIdx]["optimizer"],
                    self.models[modelIdx]["label"],
                    self.hyperparameterSets[hyperparameterSetIdx]["label"],
                    self.datasets[datasetIdx]["label"],
                     self.optimizers[optimizerIdx]["label"]
                )

            
if __name__ == "__main__":
    exp = SimpleStaticExperiment('kera', [0,1],[0,1],[0,1])

    instances = exp.getExperimentInstances()

    for instance in instances:
        print(instance)
        print('\n')




